//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
// Грааль_3.mq4.
// Используется в качестве примера в статье "Мой первый Грааль".
// Сергей Ковалёв, Днепропетровск, sk@mail.dnepr.net, ICQ 64015987, http://autograf.dp.ua/.
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
//
//
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
extern int    MA1 = 11;                                  // Период 1-й МА
extern int    MA2 = 23;                                  // Период 2-й МА
extern double TP =  50;                                  // ТэйкПрофит ордера
extern double SL =  15;                                  // СтопЛосс ордера
extern double Prots= 0;                                  // Процент от свободных средств
//--------------------------------------------------------------------------------------------
int
   ret,                                                  // Направление пересечения
   total;                                                // Крличество открытых ордеров
//--------------------------------------------------------------------------------------------
double 
   Lot,                                                  // Количество лотов
   Pred,                                                 // Предыдущее значение 1-й МА (розов)
   Tek,                                                  // Текущее    значение 1-й МА (розов)
   Golub;                                                // Текущее    значение 2-й МА(голубая)
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
int init()  
   {
//============================================================================================
   SL = SL*Point;                                        // СтопЛосс в пунктах
   TP = TP*Point;                                        // ТэйкПрофит в пунктах
   return;
//============================================================================================
   }  
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
int start()  
   {
//============================================================================================
   total=OrdersTotal();                                  // Общее количество ордеров
   if (total==2)return;                                  // Уже открыты оба ордера
//--------------------------------------------------------------------------------------------
   Tek  =iMA(NULL,0, MA1, 0,MODE_LWMA, PRICE_TYPICAL, 0);// Текущее    значение 1-й МА
   Pred =iMA(NULL,0, MA1, 0,MODE_LWMA, PRICE_TYPICAL, 1);// Предыдущее значение 2-й МА
   Golub=iMA(NULL,0, MA2, 0,MODE_LWMA, PRICE_TYPICAL, 0);// Текущее    значение 2-й МА
//--------------------------------------------------------------------------------------------
   if (Peresechenie()==1) Open_Buy();                    // Движение снизу вверх = откр. Buy
   if (Peresechenie()==2) Open_Sell();                   // Движение сверху вниз = откр. Sell
   return;
//============================================================================================
   }  
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
int Peresechenie()                                       // Функция определения пересечения
   {
//============================================================================================
   if ((Pred<=Golub && Tek> Golub) ||
       (Pred< Golub && Tek>=Golub)  ) ret=1;             // Пересечение снизу вверх       
//--------------------------------------------------------------------------------------------
   if ((Pred>=Golub && Tek< Golub) ||
       (Pred> Golub && Tek<=Golub)  ) ret=2;             // Пересечение сверху вниз
//============================================================================================
   return(ret);                                          // Возвращаем направление пересечен.
   }
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
int Open_Buy()                                           // Функция открытия Buy
   {
//============================================================================================
   if (total==1)                                         // Если ордер всего один..
      {                                                  // .. значит можно открыть другой
      OrderSelect(0, SELECT_BY_POS);                     // Выделим ордер
      if (OrderType()==0)return;                         // Если он buy, то не открываемся
      }
   OrderSend(Symbol(),0, Lots(), Ask, 0, Ask-SL, Ask+TP, "", 0, 0, Blue);// Открываемся
//============================================================================================
   return;
   }
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
int Open_Sell()                                          // Функция открытия Sell
   {
//============================================================================================
   if (total==1)                                         // Если ордер всего один..
      {                                                  // .. значит можно открыть другой
      OrderSelect(0, SELECT_BY_POS);                     // Выделим ордер
      if (OrderType()==1)return;                         // Если он sell, то не открываемся
      }
   OrderSend(Symbol(),1, Lots(), Bid, 0, Bid+SL, Bid-TP, "", 0, 0, Red);// Открываемся
//============================================================================================
   return;
   }
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
double Lots()                                            // Вычисление лотов
   {
//============================================================================================
   Lot=NormalizeDouble(AccountEquity()*Prots/100/1000,1);// Вычисляем колич. лотов  
   double Min_Lot = MarketInfo(Symbol(), MODE_MINLOT);   // Минимально допустимая стоим. лотов
   if (Lot == 0 ) Lot = Min_Lot;                         // Для теста на постоян. миним. лотах
//============================================================================================
   return(Lot);
   }
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
//

